[
    {
        "start": 0.0,
        "text": "series I think everyone's been here before so I don't think I really need to explain what the seminar series is there should be a sign-in sheet maybe it's been cast awesome it's being passed around please sign it it helps us with the pizza and we like our pizza here so today I'm pleased to present our speaker Chris Gates who works for the banner for max core and many of you also may know him as one of the DCN be it master students thanks Marci so today we're gonna do a couple of things I promise to introduce three habits that bridge research code and sustainable software so first thing I want to tell you a little bit about where I'm coming from why this is important to me why it may be relevant to you I'm going to spend a little bit of time talking about some of the differences between research code and sustainable software because it's important that we have a shared understanding on what I'm talking about there and then we're going to dive into the three habits and I'll say right from the outset these habits they're not "
    },
    {
        "start": 60.48,
        "text": "technology habits they're not even code level practices they're really processes that can be applied not only in software engineering and in research but but even beyond so it should be very technology agnostic so a little bit a little bit about me I've spent the last 20 years in information technology across a couple different roles I spent the last 15 doing various software engineering for organizations both commercial and academic groups since well in 2007 I joined up with compendium Biosciences which was founded by Dan Rhodes alumnus of this program and there I worked on array of tools but the the flagship product was on combine which is a data mining tool for cancer data sets in 2012 I joined the University of Michigan bioinformatics core and my yeah shoutout "
    },
    {
        "start": 122.6,
        "text": "that was pretty lame let's do it again shout out so the bioinformatics core helps researchers across the university identify and analyze patterns in DNA they have a range of different kind of experiment types and analysis types they support emphasis on next-generation sequencing but also some microarray what I do there I'm the I'm the lead software engineer and what that means in practice is that I'll EA's with different IT organizations at the University and make sure that we have the computer environment that we need the storage that we need to do our jobs I also do bioinformatics projects for researchers and what I'm not doing those things I get to do a little bit of software engineering and that software engineering is sometimes longer projects like collaborating with the Koretz ler group on building out nefra seek which is kind of a cousin of all combined but focused on kidney disease sometimes I'm building tools tools that help us do our core analyses or tools that might help a "
    },
    {
        "start": 184.65,
        "text": "researcher interpret some more some less standard pattern so before I jump ahead it would help me to understand where you're coming from a little bit how many people in this room occasionally write code I see a show of hands Wow a lot of people good ok how many people in this room do wet lab work work at a bench just you that's right that's fine you get here you're welcome it's just going to be it's gonna make the next step a little interesting so how many people here understand Roman numerals okay about half interesting good how many people here are comfortable raising their hands okay interesting null model how many people here are not comfortable not willing to raise their hand Thanks thanks for illustrating the principle rich I do appreciate that so let's jump in and let's talk a little bit about research code and sustainable the software and the first thing I want to "
    },
    {
        "start": 244.98,
        "text": "do is actually want to set up a contrast between the two now both research code and sustainable software use computers to produce some kind of useful results when you think about research code research code is optimized for enabling discovery the interaction with the code is typically somewhat informal it's usually exploratory the operational knowledge that is an understanding of how it's put together what it's capable of where its boundary conditions are that's usually in the head of somebody ahead of the author maybe and it's targeted towards either the author's themselves or a really focused group of subject experts and typically with research code the lifecycle of research code is comparatively short you're writing us for a very focused thing and it spends most of its time actually in development so you're gonna build something you're gonna figure something out and then you're gonna move on when you contrast that with sustainable software walk in "
    },
    {
        "start": 307.47,
        "text": "that same list sustainable software is often optimized not for discovery but for trying to maintain complexity the interaction is much more structured it's much more formal the operational knowledge is sometimes in people's heads but we hope that it's also written down somewhere and that could be evident in the architecture of the code but it might be also user documentation or architectural documentation the target users are not as focused you're looking at not just the authors but people in the field and the lifecycle if it's truly sustainable you hope the lifecycle is long and in a typical software project the maintenance phase of the life cycle takes up between 60 and 80% so it's very important for sustainable software to have a low maintenance profile it can't be very expensive to maintain because it won't be sustainable now if you look at the last two things here the target users and the lifecycle those end up being somewhat measurable "
    },
    {
        "start": 369.15,
        "text": "somewhat quantitative attributes of software and if you plot those on a graph you start to see another way you can think about the difference between sustainable software and research code so on the y-axis if you consider the life cycle which you can roughly estimate as the number of times you're going to run this thing the number of times a user is going to login or users going to execute a certain part of code so down here at the bottom maybe you're doing some kind of discovery project maybe you're even doing like some kind of a homework assignment you only get to run this once and then you're gonna move on that's five if you look at the x-axis how many users have to understand this implementation how many users have to maintain this implementation again using a simple example where you're the only you're that you're the author you're the consumer you're the developer homework assignment would be out here and when you look at when you look at things "
    },
    {
        "start": 430.11,
        "text": "broken down by how many times you have to execute it and how many people have to understand the solution what you find is that you can develop an operational profile that measures how expensive is it for this thing to remain in this state right here this is where research code really wants to live this is a good niche for research code now many people have to understand it it doesn't have to get execute a lot of times it's fine as more people need to understand it as you realize it has a longer life cycle the same patterns that served you well that helped exploratory research an ad hoc re-engineering those patterns start to work against so now this is an important point this is my school of thought by the way my school of thought and this is just based on the last I'm gonna say eight years of doing this research code does not have a teleological relationship with sustainable software research code does not want to become sustainable software in general research "
    },
    {
        "start": 492.9,
        "text": "covered informs and inspires sustainable software so research so sustainable software depends on research code but these two things they're actually quite different things rich are you using using some language I'm not gonna say anything about Perl yeah if you write a script that works that is a proof of concept that establishes this is scientifically valid that's great but if you expect to release it to a large number of users and support it over a long life cycle you probably want to revisit some of those assumptions focus that execution down and by doing that you're going to end up with a different implementation I generally start from "
    },
    {
        "start": 557.16,
        "text": "scratch yeah the number of users you can think of that as an operational scalability like scalability when people say scalability they often say they're thinking about computational scalability like will it work an eight-course will work in 72 colors oh or will it work with 50 gig drives or will it work with 50 terabyte drives but an operational scale scalability is the idea of how many people can interact with this and still get meaningful results and that is very expensive yeah so having said that the interesting thing is that research code and sustainable software actually share a lot of values research code wants to be reproducible sustainable software wants to be reproducible - it doesn't call it doesn't use that same language they talk about robustness and portability and reusability but those things taken together very very much "
    },
    {
        "start": 617.73,
        "text": "related to reproducibility research code should support publication and ideally you should be the first and sustainable software is optimized to accelerate time to market both research code and sustainable software value correctness they ant value of simplicity and before with that I'm gonna jump into some of the practices but before I do I also want to claim that this is this is my experience these are probably not all the values these are prevalent on all the great habits and what I'm sharing with you should be taken as descriptive rather than prescriptive and also I'm deeply pragmatic so do more of what works and less of what doesn't if it doesn't work with you do something else so start talking about version control now is anybody here used a lab notebook "
    },
    {
        "start": 679.29,
        "text": "so a lot of people use a lab notebook okay that's great Scott why do you use a lab notebook as a convenient way to record what lab experiments sort of in sequence to provide context for results keep track of exactly what I've done okay why is it useful because well when I was doing it I was working in the private sector and they were compliance issues eventually you may need an exact record for you know drug applications which okay thanks yeah other people have other reasons other motivations for using a lab notebook yeah so no book could assist reproducibility by getting that context out of your head and on into a document that can be shared that supports collaboration those are all really good ideas rich do use a pencil "
    },
    {
        "start": 749.52,
        "text": "second let me ask this question how many people here right now use a version control system in their work okay a section of you that's great that's actually a trick question because everybody here uses some kind of version control right now if you're not using an explicit version control system like git or CBS or perforce or whatever it is you're using you're using the file system everybody's done this I've done this I did this earlier this week so I'm gonna use a toy example which is my New Year's resolutions this the example is simple but these are very very important resolutions for me so I might stop or I might start by saying I'm gonna stop cursing I'm gonna loosen weight I'm gonna stick that in a file called resolutions dot text okay everything is great so far but then I go back and I decide I really should revise this because I really want these resolutions to work so I'm gonna make another file I'm gonna copy this file let's save that file because I want it for provenance resolutions December "
    },
    {
        "start": 811.6,
        "text": "oh five text and what if I do added a few things where to add I want to exercise more I want to cut out sugar that's fine okay so far so good okay I'm gonna keep doing this I'm iterative I don't know if you picked up on that yet but I'm very iterative so now I've got the first two files I'm capturing those I haven't gotten rid of those but now I've got a new file and now I've got a when did I do this maybe like the 21st of December and now I'm giving some kind of a reason I'm trying to make them more objective so that's the floss is for someone times a day limit cursing in front of kids okay lose ten pounds so forth and so on this works okay but it's problematic because what you would with this a directory that looks like this you won't see in this directory I know yet if you have to ask these questions which are really the really objective questions like what's the most current file here then it can tell me what the most current file is not obvious really okay "
    },
    {
        "start": 876.75,
        "text": "well what's the what's the problem is these files how you know what order they were revised and if I have to go back to a certain point in time like if I generated a results or something if I'm gonna step out of this analogy what version of this thing did I use to generate this result so I it's really hard to capture the motivations for the changes and some of the metadata around the changes now you could do it you could stop some kind of a naming convention and hope that you hold to it and hope that it works but you're really starting to strain against what the file system is designed to do so alternatives to use a version control system like git git is something that I started using I actually really started using git seriously about two years ago but I started using version control about twelve years ago and I've used a couple different systems I'm about good today how many people use get oh yes alright um well I'll just I'll "
    },
    {
        "start": 939.269,
        "text": "just say what I'm gonna say here so get its a different approach you got you've got the content of the file you've got the file name and with git you're going to take a snapshot of that directory by saying I'm going to commit this directory into a repository and that stores like a photograph of that file systems analogy and then if you want to make further changes you go and you continue to edit that same file name and after you've made a coherent set of changes you do another commit and the key is that it stores the most current version but it also retains the earlier history at each time it's doing that snapshot it's capturing not only the changes buts capturing the metadata of when that a commit occurred who initiated it and the motivation why that commit is there what's nice about this is that it's separating your file name from we're trying to capture as some kind of a file naming convention and what's really nice about it is that once "
    },
    {
        "start": 1000.98,
        "text": "you've gone through this a couple different times the answer those questions becomes much easier so if I go back and I look at the instead of using a file system if I had used git to capture all those revisions to my year's resolutions what I would see is that if I look in the directory I have one file called resolutions dot txt what is the most current file resolution set to exceed C my file is there what's the order of the revisions well it just listed the order of the revisions and it put a timestamp on each of the revisions so I can see that this revision that I use in December 23rd oh that's easy that was the one that was here right because that's the oldest one for the next revision what was the change in 1 1 2016 well I have a little comment that I put there and also I can tell that I changed the file name "
    },
    {
        "start": 1062.85,
        "text": "this is not terrifically hard to do so I'll tell you what how many people haven't seen get in action let's see a show of hands there shut up that's the other question and not then wasn't that wasn't the results how many people to use get okay how many people dip their hands up right now you guys are messing with my null model all right fine rich do you okay it's actually pretty simple it's a you can use command line but you can also use their user interfaces for all the major platforms interact with it what gives you out of the box very simply is it gives you provenance and it gives you history the content of what you're managing becomes simpler the directories become cleaner "
    },
    {
        "start": 1124.06,
        "text": "because you're no longer trying to capture all that history all that motivation inside the file or as part of the file name if it gives you kind of a sketchy backup and but I mean that if you're modifying something and you actively are iterating through it making changes you can always roll back to an earlier state you have that stack of photos and you can get to any point in it which is really nice it's sketchy just because it's still on your machine so it's fine as long as your machine doesn't blow up now github is an example of a hosted version control site where basically this whole website is set up to interact with your git repository now this is free for public projects this provides really a better backup because now that entire repository that entire stack of photos is stored somewhere else so now you can blow it in your computer go to somebody else's computer download it and you're back in business so github provides really a "
    },
    {
        "start": 1184.15,
        "text": "collaboration platform so if you are working with other people and you need to share your algorithm or share your document it's super easy to do that if when you get to publishing you need to include your codebook sorry if you need to include your code as part of the result it's a great place to put that and it really expedites cooperative development when several different people are working on the same project at the same time github makes it very easy to do that very easy to manage that in very meaningful ways it's a very powerful program we use it liberally for a subset of what we do at the bottom attic score and if you do use it let me ask this question of the people that use git how many people check in once once a day how many people check in once a week so the once a day people can Hanson has "
    },
    {
        "start": 1245.94,
        "text": "to check in once a month everybody know that all the other people should have their hands at night we when we use it we check in daily and really I mean you don't have to check in if you don't make any changes but if you do make changes there's no advantage to not checking in pushing that up to to your repository any questions about github it is a website that helps your git repository work better by enabling you to share that repository with other people yeah it enables you to use a repository locally on your machine github enables you to share that with a broad array of collaborators and the people of github would probably mad at me because github "
    },
    {
        "start": 1306.33,
        "text": "is a lot more than that but that's a good starting place yet and virtually general is that there's a couple of little bumps there how many people can work with big files don't the big files and get yeah it's really designed to version control things and you edit by hand so if you're if by hand the version control it but if it's generated for example like you wouldn't want to put a sequence FASTA file in there unless you actually edit sequence FASTA files by hand and i wouldn't recommend that that's just not what it's for the other thing is that github and some other hosting providers they're typically free for public access projects you have to pay for private accounts so if your if you don't want to share your stuff just yet because you've have some awesome super secret sauce then you have to pay like five bucks a month or something and then you get some some number of private repositories so "
    },
    {
        "start": 1371.45,
        "text": "let's talk about testing testing is the second habit I want to talk about today so I started testing about 15 years ago I started testing just about when I started software engineering and to kind of help understand where we're at I need to give you a brief history of software testing in general so yes yeah okay so let's talk about that so if I say that like I'm with github but it's a private repository I kind of depend on github keeping that really private and they don't always do that absolutely so first off you can just use git locally how do "
    },
    {
        "start": 1434.01,
        "text": "I explain this what's the name of the what's the name of the machines that you use for 575 I can't remember what they're called VCS - that's a sir okay anything that you that has get installed and that you can SSH to you can use as a repository okay so you can and I have for work in the master's program used BCS - as my taury so using repository the same version control system good we're talking so the version control system shouldn't a common a version control system I'm thinking of as the entire set of operations and the model that enable you to interact with your version history in a meaningful way the "
    },
    {
        "start": 1494.26,
        "text": "repository is an example in will stay in the world of get for a second the repository is an example of the actual history for a specific project now since BCS - an example server has get installed and since I have SSH access to BCS - I can treat BCS - as the disk store from my repository for my project I don't have to go to github if I don't want a directory in its descendants yes yes while I'm thinking of the bigger repository yeah I understand what you're saying and I'm gonna okay I'm gonna answer your question I'm gonna try to answer question in two ways one I can do everything that I do on "
    },
    {
        "start": 1558.85,
        "text": "github on VCS - ok I can do it but it's all from the command line if I want to use a web interface then I can install something called get lab get lab is an open source implementation of github that I could install anywhere ok other questions yes I know you are talking about habits beneficial to us but doing version control is yes it's simple but it's also as much as your will get commit or whatnot are there any automated ways to be a transition to becoming a better habit so other ways to make embracing version control easier right well that's a little tricky I can imagine a situation where you can set up a job that executes once a day and it just get commits whatever's in your directory but kind of works a "
    },
    {
        "start": 1621.69,
        "text": "little bit against the way version control thinks about the world which control wants your commit to have like a meaningful logical unit of work associated with it so if you just committed like once a day you get a whole bunch of kind of half form solutions in your repository which is probably not what you want the idea of making git commit an easier command this for me I think with more application it becomes a more natural thing I'm to a point in how where it's really hard for me not to commit and the truth is sometimes I'm on the command line actually we've get a lot of times I'm on the command line type in that and that's just it becomes a habit and the habit gets edited out of the cost of doing it because it's a habit so that's not very good answer but I'm gonna tell you like it doesn't bother me anymore maybe that's the short answer that's true "
    },
    {
        "start": 1681.89,
        "text": "because the change is supposed to represent a logical unit of work if it doesn't then yeah you're back to kind of arbitrary date stamps yeah other questions talk about testing we'll give you the brief history of software testing software testing began with code and fix and the idea behind coded fixes you do your best you hope it works and if something's wrong you go back and you fix it and that was enough for a while as long as programs stayed pretty simple and the the use case was very focused his bigger projects came online and bigger teams came online they really needed to start formalizing this and they adopted this kind of heavyweight software development life cycle where you out you would analyze the whole problem and you'd be done with that and then you would design a solution and we done with that and then you would develop the solution and when development was finished you would test the whole thing and then when testing was done you would release it and then after release was "
    },
    {
        "start": 1743.499,
        "text": "done you were in maintenance and this is great it's called waterfall because each stage had to complete before the next stage commenced this was great except didn't work for a lot of reasons I want to focus just on the develop and test cycle what happened here was that no matter how much time you allocated to your testing the development always ran long so it always ate into the testing schedule to a point where you really didn't test it you just developed and developed and developed until almost a release and then and then they kicked you out and the testers came in for a couple of days and the end of it basically it's a more heavyweight version of this you just hope for the best so in the 90s some people started figuring out what wait a minute we know the tests are valuable we know the tests are good they help us they produce better quality output so what if instead of trying to do all the development and testing at the very end if we broke it into little chunks so we would develop a little bit and then we would test what we developed then we "
    },
    {
        "start": 1804.909,
        "text": "would develop a little bit more and we would test with the development and so forth and so on now this idea that's coupled with the idea of automated iterative testing really started to improve the quality of the code and the quality of the solutions look at this before we do in the late 90s some people figured out that if you actually invert this pattern so that instead of developing the code and testing it you test and then you develop it actually produces even more value now how the truth is the the word is still on whether this test-driven development were you ready to test before you write the code whether that's materially better than just automated iterative testing some people say it is some people say isn't but tell you what you be the judge so with test-driven development the theory is that you start by writing a failing "
    },
    {
        "start": 1866.03,
        "text": "test and then you write the code to make the test pass and then if you need to rejigger how it works that's when you do it um and if you have more to do then you go back and write out a test so who are the people again who knew okay I need some help Zack help me out I'm gonna I'm gonna let soup so first first off I'm gonna crash my computer to be a say this won't take just see what's funny is that I don't see anything on my computer which is awesome well that's good I'll keep my eyes on the screen I guess so let me close this this is really hard to do let's do this to this wouldn't work so much better if it had work can you put "
    },
    {
        "start": 1927.59,
        "text": "your laptop in your lab and face the spring that's not bad alright sorry it's alright everybody just relax you guys are too worried alright let's just let's get our bearings here oh sorry what can I do looks alright so I'm going to do a "
    },
    {
        "start": 1988.519,
        "text": "little test driven development and the reason I'm doing this by the way is not so that you will be infected with test term development mania it's because tester in development sometimes has this were of mysticism about it and it's really just not that complicated but it's different and it can be a little unintuitive if you haven't seen it done so I'm gonna start out but mister it up by writing a test and this has to be Python but this is available in all different language and platforms I'm gonna start out with that that's okay with you sorry this over here what's doing is saying what saying that there's some function up here that when I pass "
    },
    {
        "start": 2048.55,
        "text": "it the Roman numeral I it's going to give back one okay that's all it's doing and will it work any guesses how many people think this is gonna work show of hands fair enough good point alright wow that should have worked a lot worse than it did huh oh sorry sorry ho please this is a yeah so this is what I get for coding during this thing yeah yeah yeah that's a sweet the anals say what yeah yeah yeah it did work I'm actually now I'm impressed "
    },
    {
        "start": 2108.81,
        "text": "let's keep going let's see moving in there that shouldn't have worked actually but okay now it's now it's upset I don't know why the first one didn't work or yeah I don't happen there let's expand this now I'm out of position cuz I got to feeling tests let's see what I get I'm gonna go back to one feeling test we can easy so I got a test will clear this so we can see what we're doing it's no I'm just running this thing over here to actually execute the code and spit out a result like the actual syntax is not that important but I can tell from all the chatter over there that something's bad and in fact what's bad is that I'm just making this up I have written the test I have a failing test I now have to make that test pass so I'm going to do that how can I make this pass would you say "
    },
    {
        "start": 2174.61,
        "text": "oh okay alright fine I go someone I'm just gonna do this okay so let's see sweet Emma done am I done I can handle one case can somebody give me a different case can somebody give me a different Roman numeral oh okay alright alright I can do that something to use that same pattern I'm going to copy this and the expectation is that that should equal to okay I can still make that pass I'm just gonna give it the length about what I put in there cheating going on here okay oh that's a scary idea yeah okay so okay she okay "
    },
    {
        "start": 2248.33,
        "text": "yeah it's not gonna work all right so I have to get a little sassy here I could do this I could do something like this sorry I went to perlier for second I can do that but you know I'm starting to feel a little bit silly about all these Kush workaround so maybe I do something well no it's give me one more force me into this give me one more hard one or modern one no no that's too hard the okv is good I like thee I really want I really want to jump into the next thing I'm gonna do VII okay I really want to feel it you know I mean okay all right this is hard right I could do a whole bunch of like these things or I could actually knuckle down and actually do just like a tiny bit of like something that looks like it makes sense "
    },
    {
        "start": 2324.63,
        "text": "which is kind of skipping a step here okay okay it's okay so again the idea is you have some idea of what's supposed to happen you code it as an executable thing that verifies that thing happens then you write the code to make the test pass the real value in testing is not necessarily doing it test-driven where you write the test first it's doing it in little tiny chunks and automating it that's where the real value is I'll jump back to the deck here you'll see if this works when it does work okay you've seen "
    },
    {
        "start": 2385.39,
        "text": "it you can do it if you want to do it you don't have to do it if you start to do it one of the things that that's kind of interesting is that you find that the testing starts influencing the way you design the programs for example if you have the program that you wrote that was a classifier plotter and it took a bunch of data and classified that data in some awesome way and then it produced this awesome plot you could run it might be computationally correct might even be elegant but I can tell you without looking at it it's going to be hard to test it's gonna be hard to test because there's a lot of connection there's a lot of coupling between this and that that's one reason there's another reason and that is things that our user interface centric are almost always harder to test so tell you what I'm gonna make a deal if you could break that into two elements one that took a body of data and classified it into an intermediate file and another element that took that file and ran through a Potter to generate a pot this turns out to be not only easier to test but "
    },
    {
        "start": 2447.73,
        "text": "more modular be easier to test is a good thing being more modular is also a good thing because now I could use a different version of a different classifier with this plotter or I could use a different plotter with this classifier this code is now more reusable why because I was testing it as I was developing it so the benefits of automated using unit testing are that first of all it's going to improve your correctness during the development cycle it's going to encourage reuse because you are in effect modeling the interaction of users with your code of pipelines with your code of other programs with your code as the tests as more and more tests passed that's actually quantifying your progress at a very important idea is that sustainable software lives a long time and so you're typically trying to develop you know something without breaking everything else that it still does but breaking something that breaking something that "
    },
    {
        "start": 2508.78,
        "text": "it used to do while you're in hansung it is called the regression and having the automated unit tests backing you up means that well I don't know if it works but I do know that 8,000 things that were yesterday still work and unit testing typically correlates with higher quality than coded fix because again that testing affects the way you're putting things together you're making smaller chunks and you're making them all verifiable as you go at the bottom at SCORM we use a new testing literally yeah never seek is a little bit of an outlier there that was developed what did we agree on was that 10 developer years ok yeah feels like it but it's really nice because we took an application that was designed by a bunch of crazy developers and picked it up and dropped it down into a totally new environment with entirely new set of servers and reworked it in a matter of months and nobody actually thought we could do that but the reason that we "
    },
    {
        "start": 2570.19,
        "text": "could do that was in large part because we had all those tests protecting us from making mistakes it seems like there's a little bit of a chicken if you're going to test first develop the test yep no no what you think you think you're going backwards but you're really going forwards because uh this is this is a problem with testing so a couple of things that I'll just point out that are problematic about testing if your mathematics oftentimes using stochastic stochastic algorithm those are harder to test you should be able to see it and if you write an algorithm that's stochastic somebody should be able to seed you big data that you use is slower excerpt it and use the tests and smaller data you eyes are always hard to test simpler problems usually are the testing usually "
    },
    {
        "start": 2632.93,
        "text": "shines when you're working with a more complex problem it's it's there's a learning curve and getting used to have actually write tests by the way even though you have tests it doesn't mean that it's doing the right thing oops you actually need a good problem model and that's what you're leading to and that brings me to actually the last thing that I wanted to talk about that's pair programming have you ever had to explain something that you thought you understood to someone else and found out that it was actually pretty hard to do I know I have I feel like I'm doing it right now but in the course of explaining sometimes what you do is you find out that oh there's a lot of assumptions here actually I could say it much more clearly and in fact in the course of explaining something you are demonstrating a shared understanding that is a huge value sorry that is a huge value in the idea of pairing and pairing quite simply is having two people sitting at one keyboard and "
    },
    {
        "start": 2694.94,
        "text": "that's essential because you have to be operating off the right model if you don't have the right model it's probably going to work no matter no matter what your habits are so pairing the idea that you're gonna put two people in a single project to get a single keyboard it's a little counterintuitive if you look at a parallel development model where you have two two Alpers Ted and Amanda test works on project 1 Amanda works on project 2 for the sake of argument we'll say both projects are going to be complete in two months which means that from a lab perspective from a PI perspective you're spending six developer months to get these two projects done and then you come in to the PI and you say hey what I really want to do is I want to have Ted and a man to work together or like up Ted I want to work with Amanda and they think oh wow well then I'm not gonna get this these things done for six months because you're gonna have to work on this thing which takes three months and you're gonna have to work on that and that in fact would be true if software development were about typing but thank goodness it's not because some people in "
    },
    {
        "start": 2757.55,
        "text": "here have seen me tight so there's my problem solving and this is kind of magical if you pair two people together they can actually arrive at a better solution in less time this is really really important if you put them if you keep them separate it will take them six months or three months to do this but if you put them together it will take roughly half the time which means that you have an answer to your research question in half of the time that's a huge deal this is an amazing thing the idea that two people working together can actually make substantive progress on modeling the problem twice as fast this actually is very validating by the way as a software engineer because I really didn't think that my job is about tightening I thought it was about thinking faster and that's what this represents yes "
    },
    {
        "start": 2821.99,
        "text": "you spotted that it's not exactly it's not exactly twice as fast there's a little disheartened diseconomy of scale that's right and interacting with this person in this way an intern with another person can actually clarify your thinking this is a crazy idea but it does bear out that's correct well I'm sure that's correct like this is from the extreme programming model where you have two developers that are working on a single keyboard you can mix in domain experts or usability people you can do that that's allowed but what I'm talking about is two developers "
    },
    {
        "start": 2885.85,
        "text": "that's true - there's a wonderful solution and we did it in half the time so if you were to if you were to if you're willing to take the penalty of about a 20% increase in effort what you get out of this is amazing because now two people understand your solution which is a huge difference than just one person understanding solution your code base is much more homogeneous because these two people have to agree on a lot of patterns you're probably done earlier and if from a p.i perspective instead of managing two projects and two teams you're managing one project in one team at a time which can be a big win and rich no I know we're gonna get to that okay so I'm gonna talk just a little bit about amplicon soft clipper which is something that Pete and I did largely at the last couple of weeks of December we spent about 16 hours writing tests this test looks a little different than the test I was developing we were writing these tests and it took us about 16 hours to figure out how to think about "
    },
    {
        "start": 2946.7,
        "text": "this problem I don't have those 16 hours on tape so I can't actually show the show the discussions there's no doubt in my mind that we'd still be doing it if we were trying to do it independently so I think a huge win is the idea that you get to a good model sooner when you're pairing does always work that's to be available sorry Ross sorry just it helps if you have somebody that's pretty good at pairing around you to model that behavior in some places I mean from where I sit software engineering and bioinformatics for both team sports so I'm not I'm not trying to bring home single trophy but there are there are organizations that are more focused trying to individual ownership and pairing doesn't always work in that direction the last problem seems like a joke but it's actually real problem is furniture this is a very nice-looking desk and it's awful the pair at this is "
    },
    {
        "start": 3006.869,
        "text": "actually a very nice pairing desk this is an advanced version but focus on this this is this is actually probably pretty good enough so yeah these habits they they really do I think benefit both research code and sustainable software at least in my experience importantly how that's don't make better decisions they don't necessarily make better solutions what they do these habits because they make bad decisions more painful okay so you're getting that feedback you've got a marker that you didn't have before likewise any habit that you're introducing for the first time is going to reduce your efficiency at the outset this is true of anything okay so patience and fortitude conquers all but you got any patience and fortitude and the last thing I'm gonna say about this is a quote from Greg Wilson in his 2020 14 paper science it's more than a body of knowledge it's a way of doing things that enables and encourages collaboration and I think that these habits are following that "
    },
    {
        "start": 3067.95,
        "text": "philosophy so with that I want to thank everybody for coming I want to thank you bioinformatics core for indulging me in these practices I especially want to thank some of the people at the bio from X core who have embraced these practices and through their enthusiastic adoption have contributed materially to a lot of successful projects so Anna Bob Divya Pete Jessica Kevin and Ross thank you very much and thank you [Applause] questions is that clear fine if you want to it's absolutely not about technical skill in fact I've seen people to people "
    },
    {
        "start": 3129.089,
        "text": "and this is important because what you just said works both ways I have seen two people with moderate technical skill prepare in a way where they're actually achieving much higher quality at much higher velocity just weird but I've seen it happen likewise I've seen some super technical people that just do not feel comfortable in that relationship and that's okay to ultimately do it more what works and do less of what does it but also I am NOT good I think I'm a good judge of character you aside I think I'm a good judge of character and I thought that I would be able to look go out and be like oh you're gonna peirong you're not gonna pairing your good appearing I'm terrible at this I'm always surprised by the successes and the failures so my advice here would be if you want to know if two people compare together pair them don't try to don't try to guess but it's a good point if they're not pairing well it's probably not gonna work well there are thoughts other questions "
    },
    {
        "start": 3191.299,
        "text": "all right thank you oh sorry yeah I mean I think the qualities that enable a good pair are probably qualities that most people would espouse I don't know if they actually follow them but is that a single reason I don't know I haven't seen a single reason I think that the way I would answer that question is in environments where pairing has not been able to take root because there haven't been enough good pairing models so I think the more you if it's really important to you or it's really important to your organization then trying to find trying to find the right pair partner well I think create that that model that can spread same thing "
    },
    {
        "start": 3256.45,
        "text": "with T cuz I've been in the corporate environment they did all individual recognition while they were forcing people teams didn't work right they didn't change but in the organizations where you can adopt pairing and pairing is acknowledged people are incentivized to pair one of the other benefits that I haven't mentioned is you get an idea of collective code ownership we're suddenly like you you're really you're really invested in the success of the organization and the quality of the product just pretty cool and it works but you're absolutely right and I have worked in organizations that are extraordinarily dogmatic about pairing and other organizations that are more opportunistic about pairing and here again on that continuum I say be pragmatic do what you think works and do more of it I have been a part of that actually it works better than you think "
    },
    {
        "start": 3318.49,
        "text": "it was all right thanks very much [Applause] "
    }
]